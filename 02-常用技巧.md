# 02-常用技巧

- 常用技巧
- 日期时间



## 查询所有数据库名和表名

```sql
-- 查询表名
select table_name
from information_schema.tables
where table_schema='database_name' and table_type='base table';

-- 查询字段名
select column_name
from information_schema.columns
where table_schema='database_name' and table_name='table_name';
```

<br/>

## 随机抽样

```sql
-- 随机抽样1000行
select *
from tablename
order by rand()
limit 1000;
```

<br/>

## 常用数值处理

```sql
-- 缺失值填充0
,ifnull(,ifnull(column_name,0),0)

-- md5加密
,md5(column_name)

-- 字符转为数值
,column_name*1

-- 保留两位小数，四舍五入
,round(column_name, 2)

-- 字符替换
,replace(column_name, '-', '')

-- 截取字符串中第1-第10位
,substr(column_name, 1, 10)

-- 计算逗号隔开的单词数
,length(type)-length(replace(type,',',''))+1

-- 根据json格式：{……, 'grade': 'A'}，提取其中等级
,convert(
         substr(report,
                locate('\'grade\': \'',report) + length('\'grade\': \''), 
                locate('\'}',report) - locate('\'grade\': \'',report) - length('\'grade\': \'')
               )
         using utf8
		) grade	
```



<br/>

## 实现累加功能

```sql
-- 方法1
set @csum := 0;
select 
 date
,cnt
,(@csum := @csum + cnt) cum_cnt
from 
	(
     select 
      date(create_time) date
     ,count(id) cnt
     from app_apply_info
     where date(create_time) between '2021-01-01' and '2021-02-01'
     group by 1
	) a;

-- 方法2
select 
 t1.date
,t1.cnt
,sum(t2.cnt) cum_cnt
from 
	(
	 select 
	  date(create_time) date
	 ,count(id) cnt
	 from app_apply_info
	 where date(create_time) between '2021-01-01' and '2021-02-01'
	 group by 1
	) t1
join
	(
	 select 
	  date(create_time) date
	 ,count(id) cnt
	 from app_apply_info
	 where date(create_time) between '2021-01-01' and '2021-02-01'
	 group by 1
	) t2
on t1.date >= t2.date
group by 1;
```

<br/>

## 窗口函数

```

```





<br/>

## 2、用if实现row_number() over(partion by columns order by cloumns asc) 即每行面前按自己想要的逻辑添加序号 ：计算出每日单量第一的大区

```mysql
SELECT * FROM (
SELECT a.*
, IF(@city=a.dateon, @rank:=@rank+1, @rank:=1) rank, @city:=a.dateon
 FROM 
	 (
select 
	shop.area_type
	,date(final_input_time) dateon
	,count(*) cnt
	from  tablename debit
	left join shop on shop.id=debit.shop_id
	where 
	debit.final_input_state=1
	and date(final_input_time) >='2020-06-01'
	and debit.hidden=0
group by
	area_type
	,dateon
	order by dateon,cnt desc
) a, (SELECT @city:=0,@rank:=0) b

) c 
WHERE rank =1;	
	
```

<br/>

## 3、可以将a列的不同b列的值放在同一行里面，用逗号隔开，且取最值    某个订单有很多人做过回访，查询哪些人做过回访，并且第一次回访的时间是什么时候，第一次回访的人是谁

```mysql
select
a.order_id,
a.mobile,
a.final_input_time apply_time,
substring_index(group_concat(b.worke_name order by b.create_time desc),',',1) marketer,
group_concat(b.worke_name order by b.create_time desc) total_marketers,
group_concat(distinct b.worke_name order by b.create_time desc) total_distinct_marketers, -- == 去重并列
substring_index(group_concat(b.create_time order by b.create_time desc),',',1) marketing_time
from duckchatdb.order_info a
left join duckchatdb.customer_market_record b on a.mobile=b.call_phone and a.final_input_time>b.create_time and a.user_accept=1 and a.order_type=2
where a.user_accept=1 and a.order_type=2 -- and datediff(date(a.user_accept_time),date(now()))=0
group by 1

group_concat：可以将a列的不同b列的值放在同一行里面，用逗号隔开
substring_index：截取
```

<br/>

## 4、拆分字段：把同一行里面有逗号隔开的内容，拆分成多行 即group_concat的逆写法

```sql
法一：
select 
distinct substring_index(substring_index(shop_id,',', b.help_topic_id+1),',',-1) shop_id
from 
(
    select distinct replace(refuse_name,'商户号=','') shop_id
from credit_auto_check_errinfo
where refuse_name like '商户号=%'
) a
join mysql.help_topic b on b.help_topic_id < (length(a.shop_id) - length(REPLACE(a.shop_id, ',', '')) + 1)

(length(a.shop_id) - length(REPLACE(a.shop_id, ',', '')) + 1):计算字符串中被逗号隔开的字符数
```

```sql
法二：
select 
distinct substring_index(substring_index(shop_id,',', b.int_value+1),',',-1) shop_id
from (select distinct replace(refuse_name,'商户号=','') shop_id
   from credit_auto_check_errinfo
   where refuse_name like '商户号=%') a
join (
SELECT x1.N + x10.N*10 + x100.N*100 + x1000.N*1000 as int_value
FROM (SELECT 0 AS N UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5 UNION ALL SELECT 6 UNION ALL SELECT 7 UNION ALL SELECT 8 UNION ALL SELECT 9) x1,
       (SELECT 0 AS N UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5 UNION ALL SELECT 6 UNION ALL SELECT 7 UNION ALL SELECT 8 UNION ALL SELECT 9) x10,
       (SELECT 0 AS N UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5 UNION ALL SELECT 6 UNION ALL SELECT 7 UNION ALL SELECT 8 UNION ALL SELECT 9) x100,
       (SELECT 0 AS N UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5 UNION ALL SELECT 6 UNION ALL SELECT 7 UNION ALL SELECT 8 UNION ALL SELECT 9
       ) x1000
 WHERE x1.N + x10.N*10 + x100.N*100 + x1000.N*1000 <= 10000)
 b on b.int_value < (length(a.shop_id) - length(REPLACE(a.shop_id, ',', '')) + 1);

```

参考文档： https://blog.csdn.net/qq_31780525/article/details/54416320 

<br/>

## 创建或删除（只需了解即可）

- 创建表或者视图  

表和视图对于查询者来说区别不大，主要是本身的差别。储存数据是通过表来实现的，有物理存储空间。视图是物理不存在的，相当于子查询。

```mysql
create view IF NOT EXISTS view_01 as
(select * from tablename limit 100);
```

- 删除表或者视图

```mysql
drop view view_01;
```

<br/>



------

# 日期时间类

## 移动平均

```mysql
--Day by day  3日进件量的移动平均

select  
a.dateon
,avg(b.cnt) avgorder
from 
(
select 
date(basic_time) dateon
,count(distinct id) cnt
from duckchatdb.debit_order
where date(basic_time) >= '2016-09-01' 
and apply_state in (1,2)
and ( hidden=0 or hidden_reason in (2,6) )
group by 
date(basic_time)
) a
left join 
(
select 
date(basic_time) dateon
,count(distinct id) cnt
from duckchatdb.debit_order
where date(basic_time) >= '2016-09-01' 
and apply_state in (1,2)
and ( hidden=0 or hidden_reason in (2,6) )
group by 
date(basic_time)
) b on      DATEDIFF(a.dateon,b.dateon) between 0 and 2
group by a.dateon
order by a.dateon asc
```

<br/>

## 生成日期列

```mysql
select * from 
(select adddate('1970-01-01', t4*10000 + t3*1000 + t2*100 + t1*10 + t0) `统计日期` from 
(select 0 t0 union select 1 union select 2 union select 3 union select 4 union select 5 union select 6 union select 7 union select 8 union select 9) t0, 
(select 0 t1 union select 1 union select 2 union select 3 union select 4 union select 5 union select 6 union select 7 union select 8 union select 9) t1, 
(select 0 t2 union select 1 union select 2 union select 3 union select 4 union select 5 union select 6 union select 7 union select 8 union select 9) t2, 
(select 0 t3 union select 1 union select 2 union select 3 union select 4 union select 5 union select 6 union select 7 union select 8 union select 9) t3, 
(select 0 t4 union select 1 union select 2 union select 3 union select 4 union select 5 union select 6 union select 7 union select 8 union select 9) t4) v 
where `统计日期` between '2020-10-28' and now()
;
```

<br/>

## 常用的日期函数

```mysql
今天：select now ()
今天：select current_date()
昨天：select date_sub(current_date(),interval 1 day)
本周周一：select date_sub(curdate(),interval weekday(curdate()) + 0 day)
上周周一：select date_sub(curdate(),interval weekday(curdate()) + 7 day)
上周周日：select date_sub(curdate(),interval weekday(curdate()) + 1 day)
本月1号：select date_add(curdate()-day(curdate())+1,interval 0 month)
本月1号：select date_add(curdate(),interval -day(curdate())+1 day)
本月的最后一天：select last_day(curdate())
上个月的最后一天：select last_day(DATE_SUB(CURRENT_DATE(), INTERVAL 1 month))
上个月的今天：select date_add(now(), interval -1 month) 

今天是2013年5月20日。
date_sub('2012-05-25',interval 1 day) 表示 2012-05-24
date_sub('2012-05-25',interval 0 day) 表示 2012-05-25
date_sub('2012-05-25',interval -1 day) 表示 2012-05-26
date_sub('2012-05-31',interval -1 day) 表示 2012-06-01
date_sub(curdate(),interval 1 day) 表示 2013-05-19
date_sub(curdate(),interval -1 day) 表示 2013-05-21
date_sub(curdate(),interval 1 month) 表示 2013-04-20
date_sub(curdate(),interval -1 month) 表示 2013-06-20
date_sub(curdate(),interval 1 year) 表示 2012-05-20
date_sub(curdate(),interval -1 year) 表示 2014-05-20


date_add(date,interval num unit)
#向后偏移时间
select
 "2019-01-01" as col1
 ,date_add("2019-01-01",interval 7 year) as col2
 ,date_add("2019-01-01",interval 7 month) as col3
 ,date_add("2019-01-01",interval 7 day) as col4
select
 "2019-01-01 01:01:01" as col1
 ,date_add("2019-01-01 01:01:01",interval 7 hour) as col2
 ,date_add("2019-01-01 01:01:01",interval 7 minute) as col3
 ,date_add("2019-01-01 01:01:01",interval 7 second) as col4
#向前偏移时间
select
 "2019-01-01" as col1
 ,date_sub("2019-01-01",interval 7 year) as col2
 ,date_sub("2019-01-01",interval 7 month) as col3
 ,date_sub("2019-01-01",interval 7 day) as col4

select
"2019-01-01" as col1
 ,date_add("2019-01-01",interval -7 year) as col2
 ,date_add("2019-01-01",interval -7 month) as col3
 ,date_add("2019-01-01",interval -7 day) as col4

#两日期做差
datediff(end_date,start_date)
select datediff("2019-01-07","2019-01-01")


#两时间做差
timestampdiff(second, create_time, update_time)

```



